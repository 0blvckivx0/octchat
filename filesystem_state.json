{"file_contents":{"run.sh":{"content":"#!/bin/bash\nset -e\nif ! command -v python3 &>/dev/null; then echo \"python3 not found\"; exit 1; fi\n[ ! -d \"venv\" ] && python3 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\npython cli.py\n","size_bytes":209},"cli.py":{"content":"#!/usr/bin/env python3\nimport json, base64, hashlib, time, sys, re, os, shutil, asyncio, aiohttp, threading\nfrom datetime import datetime, timedelta\nfrom concurrent.futures import ThreadPoolExecutor\nimport nacl.signing\nimport secrets\nfrom cryptography.hazmat.primitives.ciphers.aead import AESGCM\nimport hmac\nimport ssl\nimport signal\n\nc = {'r': '\\033[0m', 'b': '\\033[34m', 'c': '\\033[36m', 'g': '\\033[32m', 'y': '\\033[33m', 'R': '\\033[31m', 'B': '\\033[1m', 'bg': '\\033[44m', 'bgr': '\\033[41m', 'bgg': '\\033[42m', 'w': '\\033[37m'}\n\npriv, addr, rpc = None, None, None\nsk, pub = None, None\nb58 = re.compile(r\"^oct[1-9A-HJ-NP-Za-km-z]{44}$\")\nμ = 1_000_000\nh = []\ncb, cn, lu, lh = None, None, 0, 0\nsession = None\nexecutor = ThreadPoolExecutor(max_workers=1)\nstop_flag = threading.Event()\nspinner_frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏']\nspinner_idx = 0\n\ndef cls():\n    os.system('cls' if os.name == 'nt' else 'clear')\n\ndef sz():\n    return shutil.get_terminal_size((80, 25))\n\ndef at(x, y, t, cl=''):\n    print(f\"\\033[{y};{x}H{c['bg']}{cl}{t}{c['bg']}\", end='')\n\ndef inp(x, y):\n    print(f\"\\033[{y};{x}H\", end='', flush=True)\n    return input()\n\nasync def ainp(x, y):\n    print(f\"\\033[{y};{x}H\", end='', flush=True)\n    try:\n        return await asyncio.get_event_loop().run_in_executor(executor, input)\n    except:\n        stop_flag.set()\n        return ''\n\ndef wait():\n    cr = sz()\n    msg = \"press enter to continue...\"\n    msg_len = len(msg)\n    y_pos = cr[1] - 2\n    x_pos = max(2, (cr[0] - msg_len) // 2)\n    at(x_pos, y_pos, msg, c['y'])\n    print(f\"\\033[{y_pos};{x_pos + msg_len}H\", end='', flush=True)\n    input()\n\nasync def awaitkey():\n    cr = sz()\n    msg = \"press enter to continue...\"\n    msg_len = len(msg)\n    y_pos = cr[1] - 2\n    x_pos = max(2, (cr[0] - msg_len) // 2)\n    at(x_pos, y_pos, msg, c['y'])\n    print(f\"\\033[{y_pos};{x_pos + msg_len}H{c['bg']}\", end='', flush=True)\n    try:\n        await asyncio.get_event_loop().run_in_executor(executor, input)\n    except:\n        stop_flag.set()\n\ndef ld():\n    global priv, addr, rpc, sk, pub\n    try:\n        wallet_path = os.path.expanduser(\"~/.octra/wallet.json\")\n        if not os.path.exists(wallet_path):\n            wallet_path = \"wallet.json\"\n        \n        with open(wallet_path, 'r') as f:\n            d = json.load(f)\n        \n        priv = d.get('priv')\n        addr = d.get('addr')\n        rpc = d.get('rpc', 'http://localhost:8080')\n        \n        if not priv or not addr:\n            return False\n            \n        if not rpc.startswith('https://') and 'localhost' not in rpc:\n            print(f\"{c['R']}⚠️  WARNING: Using insecure HTTP connection!{c['r']}\")\n            time.sleep(2)\n            \n        sk = nacl.signing.SigningKey(base64.b64decode(priv))\n        pub = base64.b64encode(sk.verify_key.encode()).decode()\n        return True\n    except:\n        return False\n\ndef fill():\n    cr = sz()\n    print(f\"{c['bg']}\", end='')\n    for _ in range(cr[1]):\n        print(\" \" * cr[0])\n    print(\"\\033[H\", end='')\n\ndef box(x, y, w, h, t=\"\"):\n    print(f\"\\033[{y};{x}H{c['bg']}{c['w']}┌{'─' * (w - 2)}┐{c['bg']}\")\n    if t:\n        print(f\"\\033[{y};{x}H{c['bg']}{c['w']}┤ {c['B']}{t} {c['w']}├{c['bg']}\")\n    for i in range(1, h - 1):\n        print(f\"\\033[{y + i};{x}H{c['bg']}{c['w']}│{' ' * (w - 2)}│{c['bg']}\")\n    print(f\"\\033[{y + h - 1};{x}H{c['bg']}{c['w']}└{'─' * (w - 2)}┘{c['bg']}\")\n\nasync def spin_animation(x, y, msg):\n    global spinner_idx\n    try:\n        while True:\n            at(x, y, f\"{c['c']}{spinner_frames[spinner_idx]} {msg}\", c['c'])\n            spinner_idx = (spinner_idx + 1) % len(spinner_frames)\n            await asyncio.sleep(0.1)\n    except asyncio.CancelledError:\n        at(x, y, \" \" * (len(msg) + 3), \"\")\n\ndef derive_encryption_key(privkey_b64):\n    privkey_bytes = base64.b64decode(privkey_b64)\n    salt = b\"octra_encrypted_balance_v2\"\n    return hashlib.sha256(salt + privkey_bytes).digest()[:32]\n\ndef encrypt_client_balance(balance, privkey_b64):\n    key = derive_encryption_key(privkey_b64)\n    aesgcm = AESGCM(key)\n    nonce = secrets.token_bytes(12)\n    plaintext = str(balance).encode()\n    ciphertext = aesgcm.encrypt(nonce, plaintext, None)\n    return \"v2|\" + base64.b64encode(nonce + ciphertext).decode()\n\ndef decrypt_client_balance(encrypted_data, privkey_b64):\n    if encrypted_data == \"0\" or not encrypted_data:\n        return 0\n    \n    if not encrypted_data.startswith(\"v2|\"):\n        privkey_bytes = base64.b64decode(privkey_b64)\n        salt = b\"octra_encrypted_balance_v1\"\n        key = hashlib.sha256(salt + privkey_bytes).digest() + hashlib.sha256(privkey_bytes + salt).digest()\n        key = key[:32]\n        \n        try:\n            data = base64.b64decode(encrypted_data)\n            if len(data) < 32:\n                return 0\n            \n            nonce = data[:16]\n            tag = data[16:32]\n            encrypted = data[32:]\n            \n            expected_tag = hashlib.sha256(nonce + encrypted + key).digest()[:16]\n            if not hmac.compare_digest(tag, expected_tag):\n                return 0\n            \n            decrypted = bytearray()\n            key_hash = hashlib.sha256(key + nonce).digest()\n            for i, byte in enumerate(encrypted):\n                decrypted.append(byte ^ key_hash[i % 32])\n            \n            return int(decrypted.decode())\n        except:\n            return 0\n    \n    try:\n        b64_data = encrypted_data[3:]\n        raw = base64.b64decode(b64_data)\n        \n        if len(raw) < 28:\n            return 0\n        \n        nonce = raw[:12]\n        ciphertext = raw[12:]\n        \n        key = derive_encryption_key(privkey_b64)\n        aesgcm = AESGCM(key)\n        \n        plaintext = aesgcm.decrypt(nonce, ciphertext, None)\n        return int(plaintext.decode())\n    except:\n        return 0\n\ndef derive_shared_secret_for_claim(my_privkey_b64, ephemeral_pubkey_b64):\n    sk = nacl.signing.SigningKey(base64.b64decode(my_privkey_b64))\n    my_pubkey_bytes = sk.verify_key.encode()\n    eph_pub_bytes = base64.b64decode(ephemeral_pubkey_b64)\n    \n    if eph_pub_bytes < my_pubkey_bytes:\n        smaller, larger = eph_pub_bytes, my_pubkey_bytes\n    else:\n        smaller, larger = my_pubkey_bytes, eph_pub_bytes\n    \n    combined = smaller + larger\n    round1 = hashlib.sha256(combined).digest()\n    round2 = hashlib.sha256(round1 + b\"OCTRA_SYMMETRIC_V1\").digest()\n    return round2[:32]\n\ndef decrypt_private_amount(encrypted_data, shared_secret):\n    if not encrypted_data or not encrypted_data.startswith(\"v2|\"):\n        return None\n    \n    try:\n        raw = base64.b64decode(encrypted_data[3:])\n        if len(raw) < 28:\n            return None\n        \n        nonce = raw[:12]\n        ciphertext = raw[12:]\n        \n        aesgcm = AESGCM(shared_secret)\n        plaintext = aesgcm.decrypt(nonce, ciphertext, None)\n        return int(plaintext.decode())\n    except:\n        return None\n\nasync def req(m, p, d=None, t=10):\n    global session\n    if not session:\n        ssl_context = ssl.create_default_context()\n        connector = aiohttp.TCPConnector(ssl=ssl_context, force_close=True)\n        session = aiohttp.ClientSession(\n            timeout=aiohttp.ClientTimeout(total=t),\n            connector=connector,\n            json_serialize=json.dumps\n        )\n    try:\n        url = f\"{rpc}{p}\"\n        \n        kwargs = {}\n        if m == 'POST' and d:\n            kwargs['json'] = d\n        \n        async with getattr(session, m.lower())(url, **kwargs) as resp:\n            text = await resp.text()\n            \n            try:\n                j = json.loads(text) if text.strip() else None\n            except:\n                j = None\n            \n            return resp.status, text, j\n    except asyncio.TimeoutError:\n        return 0, \"timeout\", None\n    except Exception as e:\n        return 0, str(e), None\n\nasync def req_private(path, method='GET', data=None):\n    headers = {\"X-Private-Key\": priv}\n    try:\n        url = f\"{rpc}{path}\"\n        \n        kwargs = {'headers': headers}\n        if method == 'POST' and data:\n            kwargs['json'] = data\n            \n        async with getattr(session, method.lower())(url, **kwargs) as resp:\n            text = await resp.text()\n            \n            if resp.status == 200:\n                try:\n                    return True, json.loads(text) if text.strip() else {}\n                except:\n                    return False, {\"error\": \"Invalid JSON response\"}\n            else:\n                return False, {\"error\": f\"HTTP {resp.status}\"}\n                \n    except Exception as e:\n        return False, {\"error\": str(e)}\n\nasync def st():\n    global cb, cn, lu\n    now = time.time()\n    if cb is not None and (now - lu) < 30:\n        return cn, cb\n    \n    results = await asyncio.gather(\n        req('GET', f'/balance/{addr}'),\n        req('GET', '/staging', 5),\n        return_exceptions=True\n    )\n    \n    s, t, j = results[0] if not isinstance(results[0], Exception) else (0, str(results[0]), None)\n    s2, _, j2 = results[1] if not isinstance(results[1], Exception) else (0, None, None)\n    \n    if s == 200 and j:\n        cn = int(j.get('nonce', 0))\n        cb = float(j.get('balance', 0))\n        lu = now\n        if s2 == 200 and j2:\n            our = [tx for tx in j2.get('staged_transactions', []) if tx.get('from') == addr]\n            if our:\n                cn = max(cn, max(int(tx.get('nonce', 0)) for tx in our))\n    elif s == 404:\n        cn, cb, lu = 0, 0.0, now\n    elif s == 200 and t and not j:\n        try:\n            parts = t.strip().split()\n            if len(parts) >= 2:\n                cb = float(parts[0]) if parts[0].replace('.', '').isdigit() else 0.0\n                cn = int(parts[1]) if parts[1].isdigit() else 0\n                lu = now\n            else:\n                cn, cb = None, None\n        except:\n            cn, cb = None, None\n    return cn, cb\n\nasync def get_encrypted_balance():\n    ok, result = await req_private(f\"/view_encrypted_balance/{addr}\")\n    \n    if ok:\n        try:\n            return {\n                \"public\": float(result.get(\"public_balance\", \"0\").split()[0]),\n                \"public_raw\": int(result.get(\"public_balance_raw\", \"0\")),\n                \"encrypted\": float(result.get(\"encrypted_balance\", \"0\").split()[0]),\n                \"encrypted_raw\": int(result.get(\"encrypted_balance_raw\", \"0\")),\n                \"total\": float(result.get(\"total_balance\", \"0\").split()[0])\n            }\n        except:\n            return None\n    else:\n        return None\n\nasync def encrypt_balance(amount):\n    enc_data = await get_encrypted_balance()\n    if not enc_data:\n        return False, {\"error\": \"cannot get balance\"}\n    \n    current_encrypted_raw = enc_data['encrypted_raw']\n    new_encrypted_raw = current_encrypted_raw + int(amount * μ)\n    \n    encrypted_value = encrypt_client_balance(new_encrypted_raw, priv)\n    \n    data = {\n        \"address\": addr,\n        \"amount\": str(int(amount * μ)),\n        \"private_key\": priv,\n        \"encrypted_data\": encrypted_value\n    }\n    \n    s, t, j = await req('POST', '/encrypt_balance', data)\n    if s == 200:\n        return True, j\n    else:\n        return False, {\"error\": j.get(\"error\", t) if j else t}\n\nasync def decrypt_balance(amount):\n    enc_data = await get_encrypted_balance()\n    if not enc_data:\n        return False, {\"error\": \"cannot get balance\"}\n    \n    current_encrypted_raw = enc_data['encrypted_raw']\n    if current_encrypted_raw < int(amount * μ):\n        return False, {\"error\": \"insufficient encrypted balance\"}\n    \n    new_encrypted_raw = current_encrypted_raw - int(amount * μ)\n    \n    encrypted_value = encrypt_client_balance(new_encrypted_raw, priv)\n    \n    data = {\n        \"address\": addr,\n        \"amount\": str(int(amount * μ)),\n        \"private_key\": priv,\n        \"encrypted_data\": encrypted_value\n    }\n    \n    s, t, j = await req('POST', '/decrypt_balance', data)\n    if s == 200:\n        return True, j\n    else:\n        return False, {\"error\": j.get(\"error\", t) if j else t}\n\nasync def get_address_info(address):\n    s, t, j = await req('GET', f'/address/{address}')\n    if s == 200:\n        return j\n    return None\n\nasync def get_public_key(address):\n    s, t, j = await req('GET', f'/public_key/{address}')\n    if s == 200:\n        return j.get(\"public_key\")\n    return None\n\nasync def create_private_transfer(to_addr, amount):\n    addr_info = await get_address_info(to_addr)\n    if not addr_info or not addr_info.get(\"has_public_key\"):\n        return False, {\"error\": \"Recipient has no public key\"}\n    \n    to_public_key = await get_public_key(to_addr)\n    if not to_public_key:\n        return False, {\"error\": \"Cannot get recipient public key\"}\n    \n    data = {\n        \"from\": addr,\n        \"to\": to_addr,\n        \"amount\": str(int(amount * μ)),\n        \"from_private_key\": priv,\n        \"to_public_key\": to_public_key\n    }\n    \n    s, t, j = await req('POST', '/private_transfer', data)\n    if s == 200:\n        return True, j\n    else:\n        return False, {\"error\": j.get(\"error\", t) if j else t}\n\nasync def get_pending_transfers():\n    ok, result = await req_private(f\"/pending_private_transfers?address={addr}\")\n    \n    if ok:\n        transfers = result.get(\"pending_transfers\", [])\n        return transfers\n    else:\n        return []\n\nasync def claim_private_transfer(transfer_id):\n    data = {\n        \"recipient_address\": addr,\n        \"private_key\": priv,\n        \"transfer_id\": transfer_id\n    }\n    \n    s, t, j = await req('POST', '/claim_private_transfer', data)\n    if s == 200:\n        return True, j\n    else:\n        return False, {\"error\": j.get(\"error\", t) if j else t}\n\nasync def gh():\n    global h, lh\n    now = time.time()\n    if now - lh < 60 and h:\n        return\n    s, t, j = await req('GET', f'/address/{addr}?limit=20')\n    if s != 200 or (not j and not t):\n        return\n    \n    if j and 'recent_transactions' in j:\n        tx_hashes = [ref[\"hash\"] for ref in j.get('recent_transactions', [])]\n        tx_results = await asyncio.gather(*[req('GET', f'/tx/{hash}', 5) for hash in tx_hashes], return_exceptions=True)\n        \n        existing_hashes = {tx['hash'] for tx in h}\n        nh = []\n        \n        for i, (ref, result) in enumerate(zip(j.get('recent_transactions', []), tx_results)):\n            if isinstance(result, Exception):\n                continue\n            s2, _, j2 = result\n            if s2 == 200 and j2 and 'parsed_tx' in j2:\n                p = j2['parsed_tx']\n                tx_hash = ref['hash']\n                \n                if tx_hash in existing_hashes:\n                    continue\n                \n                ii = p.get('to') == addr\n                ar = p.get('amount_raw', p.get('amount', '0'))\n                a = float(ar) if '.' in str(ar) else int(ar) / μ\n                msg = None\n                if 'data' in j2:\n                    try:\n                        data = json.loads(j2['data'])\n                        msg = data.get('message')\n                    except:\n                        pass\n                nh.append({\n                    'time': datetime.fromtimestamp(p.get('timestamp', 0)),\n                    'hash': tx_hash,\n                    'amt': a,\n                    'to': p.get('to') if not ii else p.get('from'),\n                    'type': 'in' if ii else 'out',\n                    'ok': True,\n                    'nonce': p.get('nonce', 0),\n                    'epoch': ref.get('epoch', 0),\n                    'msg': msg\n                })\n        \n        oh = datetime.now() - timedelta(hours=1)\n        h[:] = sorted(nh + [tx for tx in h if tx.get('time', datetime.now()) > oh], key=lambda x: x['time'], reverse=True)[:50]\n        lh = now\n    elif s == 404 or (s == 200 and t and 'no transactions' in t.lower()):\n        h.clear()\n        lh = now\n\ndef mk(to, a, n, msg=None):\n    tx = {\n        \"from\": addr,\n        \"to_\": to,\n        \"amount\": str(int(a * μ)),\n        \"nonce\": int(n),\n        \"ou\": \"1\" if a < 1000 else \"3\",\n        \"timestamp\": time.time()\n    }\n    if msg:\n        tx[\"message\"] = msg\n    bl = json.dumps({k: v for k, v in tx.items() if k != \"message\"}, separators=(\",\", \":\"))\n    sig = base64.b64encode(sk.sign(bl.encode()).signature).decode()\n    tx.update(signature=sig, public_key=pub)\n    return tx, hashlib.sha256(bl.encode()).hexdigest()\n\nasync def snd(tx):\n    t0 = time.time()\n    s, t, j = await req('POST', '/send-tx', tx)\n    dt = time.time() - t0\n    if s == 200:\n        if j and j.get('status') == 'accepted':\n            return True, j.get('tx_hash', ''), dt, j\n        elif t.lower().startswith('ok'):\n            return True, t.split()[-1], dt, None\n    return False, json.dumps(j) if j else t, dt, j\n\nasync def expl(x, y, w, hb):\n    box(x, y, w, hb, \"wallet explorer\")\n    n, b = await st()\n    await gh()\n    at(x + 2, y + 2, \"address:\", c['c'])\n    at(x + 11, y + 2, addr, c['w'])\n    at(x + 2, y + 3, \"balance:\", c['c'])\n    at(x + 11, y + 3, f\"{b:.6f} oct\" if b is not None else \"---\", c['B'] + c['g'] if b else c['w'])\n    at(x + 2, y + 4, \"nonce:  \", c['c'])\n    at(x + 11, y + 4, str(n) if n is not None else \"---\", c['w'])\n    at(x + 2, y + 5, \"public: \", c['c'])\n    at(x + 11, y + 5, pub[:40] + \"...\", c['w'])\n    \n    try:\n        enc_data = await get_encrypted_balance()\n        if enc_data:\n            at(x + 2, y + 6, \"encrypted:\", c['c'])\n            at(x + 13, y + 6, f\"{enc_data['encrypted']:.6f} oct\", c['B'] + c['y'])\n            \n            pending = await get_pending_transfers()\n            if pending:\n                at(x + 2, y + 7, \"claimable:\", c['c'])\n                at(x + 13, y + 7, f\"{len(pending)} transfers\", c['B'] + c['g'])\n    except:\n        pass\n    \n    _, _, j = await req('GET', '/staging', 2)\n    sc = len([tx for tx in j.get('staged_transactions', []) if tx.get('from') == addr]) if j else 0\n    at(x + 2, y + 8, \"staging:\", c['c'])\n    at(x + 11, y + 8, f\"{sc} pending\" if sc else \"none\", c['y'] if sc else c['w'])\n    at(x + 1, y + 9, \"─\" * (w - 2), c['w'])\n    \n    at(x + 2, y + 10, \"recent transactions:\", c['B'] + c['c'])\n    if not h:\n        at(x + 2, y + 12, \"no transactions yet\", c['y'])\n    else:\n        at(x + 2, y + 12, \"time     type  amount      address\", c['c'])\n        at(x + 2, y + 13, \"─\" * (w - 4), c['w'])\n        seen_hashes = set()\n        display_count = 0\n        sorted_h = sorted(h, key=lambda x: x['time'], reverse=True)\n        for tx in sorted_h:\n            if tx['hash'] in seen_hashes:\n                continue\n            seen_hashes.add(tx['hash'])\n            if display_count >= min(len(h), hb - 17):\n                break\n            is_pending = not tx.get('epoch')\n            time_color = c['y'] if is_pending else c['w']\n            at(x + 2, y + 14 + display_count, tx['time'].strftime('%H:%M:%S'), time_color)\n            at(x + 11, y + 14 + display_count, \" in\" if tx['type'] == 'in' else \"out\", c['g'] if tx['type'] == 'in' else c['R'])\n            at(x + 16, y + 14 + display_count, f\"{float(tx['amt']):>10.6f}\", c['w'])\n            at(x + 28, y + 14 + display_count, str(tx.get('to', '---')), c['y'])\n            if tx.get('msg'):\n                at(x + 77, y + 14 + display_count, \"msg\", c['c'])\n            status_text = \"pen\" if is_pending else f\"e{tx.get('epoch', 0)}\"\n            status_color = c['y'] + c['B'] if is_pending else c['c']\n            at(x + w - 6, y + 14 + display_count, status_text, status_color)\n            display_count += 1\n\ndef menu(x, y, w, h):\n    box(x, y, w, h, \"commands\")\n    at(x + 2, y + 2, \"[1] send tx\", c['w'])\n    at(x + 2, y + 3, \"[2] refresh\", c['w'])\n    at(x + 2, y + 4, \"[3] multi send\", c['w'])\n    at(x + 2, y + 5, \"[4] encrypt balance\", c['w'])\n    at(x + 2, y + 6, \"[5] decrypt balance\", c['w'])\n    at(x + 2, y + 7, \"[6] private transfer\", c['w'])\n    at(x + 2, y + 8, \"[7] claim transfers\", c['w'])\n    at(x + 2, y + 9, \"[8] export keys\", c['w'])\n    at(x + 2, y + 10, \"[9] clear hist\", c['w'])\n    at(x + 2, y + 11, \"[0] exit\", c['w'])\n    at(x + 2, y + h - 2, \"command: \", c['B'] + c['y'])\n\nasync def scr():\n    cr = sz()\n    cls()\n    fill()\n    t = f\" octra client v0.1.0 (private) │ {datetime.now().strftime('%H:%M:%S')} \"\n    at((cr[0] - len(t)) // 2, 1, t, c['B'] + c['w'])\n    \n    sidebar_w = 28\n    menu(2, 3, sidebar_w, 15)\n    \n    info_y = 19\n    box(2, info_y, sidebar_w, 11)\n    at(4, info_y + 2, \"testnet environment.\", c['y'])\n    at(4, info_y + 3, \"actively updated.\", c['y'])\n    at(4, info_y + 4, \"monitor changes!\", c['y'])\n    at(4, info_y + 5, \"\", c['y'])\n    at(4, info_y + 6, \"private transactions\", c['g'])\n    at(4, info_y + 7, \"enabled\", c['g'])\n    at(4, info_y + 8, \"\", c['y'])\n    at(4, info_y + 9, \"tokens: no value\", c['R'])\n    \n    explorer_x = sidebar_w + 4\n    explorer_w = cr[0] - explorer_x - 2\n    await expl(explorer_x, 3, explorer_w, cr[1] - 6)\n    \n    at(2, cr[1] - 1, \" \" * (cr[0] - 4), c['bg'])\n    at(2, cr[1] - 1, \"ready\", c['bgg'] + c['w'])\n    return await ainp(12, 16)\n\nasync def tx():\n    cr = sz()\n    cls()\n    fill()\n    w, hb = 85, 26\n    x = (cr[0] - w) // 2\n    y = (cr[1] - hb) // 2\n    box(x, y, w, hb, \"send transaction\")\n    at(x + 2, y + 2, \"to address: (or [esc] to cancel)\", c['y'])\n    at(x + 2, y + 3, \"─\" * (w - 4), c['w'])\n    to = await ainp(x + 2, y + 4)\n    if not to or to.lower() == 'esc':\n        return\n    if not b58.match(to):\n        at(x + 2, y + 14, \"invalid address!\", c['bgr'] + c['w'])\n        at(x + 2, y + 15, \"press enter to go back...\", c['y'])\n        await ainp(x + 2, y + 16)\n        return\n    at(x + 2, y + 5, f\"to: {to}\", c['g'])\n    at(x + 2, y + 7, \"amount: (or [esc] to cancel)\", c['y'])\n    at(x + 2, y + 8, \"─\" * (w - 4), c['w'])\n    a = await ainp(x + 2, y + 9)\n    if not a or a.lower() == 'esc':\n        return\n    if not re.match(r\"^\\d+(\\.\\d+)?$\", a) or float(a) <= 0:\n        at(x + 2, y + 14, \"invalid amount!\", c['bgr'] + c['w'])\n        at(x + 2, y + 15, \"press enter to go back...\", c['y'])\n        await ainp(x + 2, y + 16)\n        return\n    a = float(a)\n    at(x + 2, y + 10, f\"amount: {a:.6f} oct\", c['g'])\n    at(x + 2, y + 12, \"message (optional, max 1024): (or enter to skip)\", c['y'])\n    at(x + 2, y + 13, \"─\" * (w - 4), c['w'])\n    msg = await ainp(x + 2, y + 14)\n    if not msg:\n        msg = None\n    elif len(msg) > 1024:\n        msg = msg[:1024]\n        at(x + 2, y + 15, \"message truncated to 1024 chars\", c['y'])\n    \n    global lu\n    lu = 0\n    n, b = await st()\n    if n is None:\n        at(x + 2, y + 17, \"failed to get nonce!\", c['bgr'] + c['w'])\n        at(x + 2, y + 18, \"press enter to go back...\", c['y'])\n        await ainp(x + 2, y + 19)\n        return\n    if not b or b < a:\n        at(x + 2, y + 17, f\"insufficient balance ({b:.6f} < {a})\", c['bgr'] + c['w'])\n        at(x + 2, y + 18, \"press enter to go back...\", c['y'])\n        await ainp(x + 2, y + 19)\n        return\n    at(x + 2, y + 16, \"─\" * (w - 4), c['w'])\n    at(x + 2, y + 17, f\"send {a:.6f} oct\", c['B'] + c['g'])\n    at(x + 2, y + 18, f\"to:  {to}\", c['g'])\n    if msg:\n        at(x + 2, y + 19, f\"msg: {msg[:50]}{'...' if len(msg) > 50 else ''}\", c['c'])\n    at(x + 2, y + 20, f\"fee: {'0.001' if a < 1000 else '0.003'} oct (nonce: {n + 1})\", c['y'])\n    at(x + 2, y + 21, \"[y]es / [n]o: \", c['B'] + c['y'])\n    if (await ainp(x + 16, y + 21)).strip().lower() != 'y':\n        return\n    \n    spin_task = asyncio.create_task(spin_animation(x + 2, y + 22, \"sending transaction\"))\n    \n    t, _ = mk(to, a, n + 1, msg)\n    ok, hs, dt, r = await snd(t)\n    \n    spin_task.cancel()\n    try:\n        await spin_task\n    except asyncio.CancelledError:\n        pass\n    \n    if ok:\n        for i in range(17, 25):\n            at(x + 2, y + i, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 20, f\"✓ transaction accepted!\", c['bgg'] + c['w'])\n        at(x + 2, y + 21, f\"hash: {hs[:64]}...\", c['g'])\n        at(x + 2, y + 22, f\"      {hs[64:]}\", c['g'])\n        at(x + 2, y + 23, f\"time: {dt:.2f}s\", c['w'])\n        if r and 'pool_info' in r:\n            at(x + 2, y + 24, f\"pool: {r['pool_info'].get('total_pool_size', 0)} txs pending\", c['y'])\n        h.append({\n            'time': datetime.now(),\n            'hash': hs,\n            'amt': a,\n            'to': to,\n            'type': 'out',\n            'ok': True,\n            'msg': msg\n        })\n        lu = 0\n    else:\n        at(x + 2, y + 20, f\"✗ transaction failed!\", c['bgr'] + c['w'])\n        at(x + 2, y + 21, f\"error: {str(hs)[:w - 10]}\", c['R'])\n    await awaitkey()\n\nasync def multi():\n    cr = sz()\n    cls()\n    fill()\n    w, hb = 70, cr[1] - 4\n    x = (cr[0] - w) // 2\n    y = 2\n    box(x, y, w, hb, \"multi send\")\n    at(x + 2, y + 2, \"enter recipients (address amount), empty line to finish:\", c['y'])\n    at(x + 2, y + 3, \"type [esc] to cancel\", c['c'])\n    at(x + 2, y + 4, \"─\" * (w - 4), c['w'])\n    rcp = []\n    tot = 0\n    ly = y + 5\n    while ly < y + hb - 8:\n        at(x + 2, ly, f\"[{len(rcp) + 1}] \", c['c'])\n        l = await ainp(x + 7, ly)\n        if l.lower() == 'esc':\n            return\n        if not l:\n            break\n        p = l.split()\n        if len(p) == 2 and b58.match(p[0]) and re.match(r\"^\\d+(\\.\\d+)?$\", p[1]) and float(p[1]) > 0:\n            a = float(p[1])\n            rcp.append((p[0], a))\n            tot += a\n            at(x + 50, ly, f\"+{a:.6f}\", c['g'])\n            ly += 1\n        else:\n            at(x + 50, ly, \"invalid!\", c['R'])\n    if not rcp:\n        return\n    at(x + 2, y + hb - 7, \"─\" * (w - 4), c['w'])\n    at(x + 2, y + hb - 6, f\"total: {tot:.6f} oct to {len(rcp)} addresses\", c['B'] + c['y'])\n    global lu\n    lu = 0\n    n, b = await st()\n    if n is None:\n        at(x + 2, y + hb - 5, \"failed to get nonce!\", c['bgr'] + c['w'])\n        at(x + 2, y + hb - 4, \"press enter to go back...\", c['y'])\n        await ainp(x + 2, y + hb - 3)\n        return\n    if not b or b < tot:\n        at(x + 2, y + hb - 5, f\"insufficient balance! ({b:.6f} < {tot})\", c['bgr'] + c['w'])\n        at(x + 2, y + hb - 4, \"press enter to go back...\", c['y'])\n        await ainp(x + 2, y + hb - 3)\n        return\n    at(x + 2, y + hb - 5, f\"send all? [y/n] (starting nonce: {n + 1}): \", c['y'])\n    if (await ainp(x + 48, y + hb - 5)).strip().lower() != 'y':\n        return\n    \n    spin_task = asyncio.create_task(spin_animation(x + 2, y + hb - 3, \"sending transactions\"))\n    \n    batch_size = 5\n    batches = [rcp[i:i+batch_size] for i in range(0, len(rcp), batch_size)]\n    s_total, f_total = 0, 0\n    \n    for batch_idx, batch in enumerate(batches):\n        tasks = []\n        for i, (to, a) in enumerate(batch):\n            idx = batch_idx * batch_size + i\n            at(x + 2, y + hb - 2, f\"[{idx + 1}/{len(rcp)}] preparing batch...\", c['c'])\n            t, _ = mk(to, a, n + 1 + idx)\n            tasks.append(snd(t))\n        \n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        for i, (result, (to, a)) in enumerate(zip(results, batch)):\n            idx = batch_idx * batch_size + i\n            if isinstance(result, Exception):\n                f_total += 1\n                at(x + 55, y + hb - 2, \"✗ fail \", c['R'])\n            else:\n                ok, hs, _, _ = result\n                if ok:\n                    s_total += 1\n                    at(x + 55, y + hb - 2, \"✓ ok   \", c['g'])\n                    h.append({\n                        'time': datetime.now(),\n                        'hash': hs,\n                        'amt': a,\n                        'to': to,\n                        'type': 'out',\n                        'ok': True\n                    })\n                else:\n                    f_total += 1\n                    at(x + 55, y + hb - 2, \"✗ fail \", c['R'])\n            at(x + 2, y + hb - 2, f\"[{idx + 1}/{len(rcp)}] {a:.6f} to {to[:20]}...\", c['c'])\n            await asyncio.sleep(0.05)\n    \n    spin_task.cancel()\n    try:\n        await spin_task\n    except asyncio.CancelledError:\n        pass\n    \n    lu = 0\n    at(x + 2, y + hb - 2, \" \" * 65, c['bg'])\n    at(x + 2, y + hb - 2, f\"completed: {s_total} success, {f_total} failed\", c['bgg'] + c['w'] if f_total == 0 else c['bgr'] + c['w'])\n    await awaitkey()\n\nasync def encrypt_balance_ui():\n    cr = sz()\n    cls()\n    fill()\n    w, hb = 70, 20\n    x = (cr[0] - w) // 2\n    y = (cr[1] - hb) // 2\n    \n    box(x, y, w, hb, \"encrypt balance\")\n    \n    _, pub_bal = await st()\n    enc_data = await get_encrypted_balance()\n    \n    if not enc_data:\n        at(x + 2, y + 10, \"cannot get encrypted balance info\", c['R'])\n        await awaitkey()\n        return\n    \n    at(x + 2, y + 2, \"public balance:\", c['c'])\n    at(x + 20, y + 2, f\"{pub_bal:.6f} oct\", c['w'])\n    \n    at(x + 2, y + 3, \"encrypted:\", c['c'])\n    at(x + 20, y + 3, f\"{enc_data['encrypted']:.6f} oct\", c['y'])\n    \n    at(x + 2, y + 4, \"total:\", c['c'])\n    at(x + 20, y + 4, f\"{enc_data['total']:.6f} oct\", c['g'])\n    \n    at(x + 2, y + 6, \"─\" * (w - 4), c['w'])\n    \n    max_encrypt = enc_data['public_raw'] / μ - 1.0\n    if max_encrypt <= 0:\n        at(x + 2, y + 8, \"insufficient public balance (need > 1 oct for fees)\", c['R'])\n        await awaitkey()\n        return\n    \n    at(x + 2, y + 7, f\"max encryptable: {max_encrypt:.6f} oct\", c['y'])\n    \n    at(x + 2, y + 9, \"amount to encrypt:\", c['y'])\n    amount = await ainp(x + 21, y + 9)\n    \n    if not amount or not re.match(r\"^\\d+(\\.\\d+)?$\", amount) or float(amount) <= 0:\n        return\n    \n    amount = float(amount)\n    if amount > max_encrypt:\n        at(x + 2, y + 11, f\"amount too large (max: {max_encrypt:.6f})\", c['R'])\n        await awaitkey()\n        return\n    \n    at(x + 2, y + 11, f\"encrypt {amount:.6f} oct? [y/n]:\", c['B'] + c['y'])\n    if (await ainp(x + 30, y + 11)).strip().lower() != 'y':\n        return\n    \n    spin_task = asyncio.create_task(spin_animation(x + 2, y + 14, \"encrypting balance\"))\n    \n    ok, result = await encrypt_balance(amount)\n    \n    spin_task.cancel()\n    try:\n        await spin_task\n    except asyncio.CancelledError:\n        pass\n    \n    if ok:\n        at(x + 2, y + 14, \"✓ encryption submitted!\", c['bgg'] + c['w'])\n        at(x + 2, y + 15, f\"tx hash: {result.get('tx_hash', 'unknown')[:50]}...\", c['g'])\n        at(x + 2, y + 16, f\"will process in next epoch\", c['g'])\n    else:\n        at(x + 2, y + 14, f\"✗ error: {result.get('error', 'unknown')}\", c['bgr'] + c['w'])\n    \n    await awaitkey()\n\nasync def decrypt_balance_ui():\n    cr = sz()\n    cls()\n    fill()\n    w, hb = 70, 20\n    x = (cr[0] - w) // 2\n    y = (cr[1] - hb) // 2\n    \n    box(x, y, w, hb, \"decrypt balance\")\n    \n    _, pub_bal = await st()\n    enc_data = await get_encrypted_balance()\n    \n    if not enc_data:\n        at(x + 2, y + 10, \"cannot get encrypted balance info\", c['R'])\n        await awaitkey()\n        return\n    \n    at(x + 2, y + 2, \"public balance:\", c['c'])\n    at(x + 20, y + 2, f\"{pub_bal:.6f} oct\", c['w'])\n    \n    at(x + 2, y + 3, \"encrypted:\", c['c'])\n    at(x + 20, y + 3, f\"{enc_data['encrypted']:.6f} oct\", c['y'])\n    \n    at(x + 2, y + 4, \"total:\", c['c'])\n    at(x + 20, y + 4, f\"{enc_data['total']:.6f} oct\", c['g'])\n    \n    at(x + 2, y + 6, \"─\" * (w - 4), c['w'])\n    \n    if enc_data['encrypted_raw'] == 0:\n        at(x + 2, y + 8, \"no encrypted balance to decrypt\", c['R'])\n        await awaitkey()\n        return\n    \n    max_decrypt = enc_data['encrypted_raw'] / μ\n    at(x + 2, y + 7, f\"max decryptable: {max_decrypt:.6f} oct\", c['y'])\n    \n    at(x + 2, y + 9, \"amount to decrypt:\", c['y'])\n    amount = await ainp(x + 21, y + 9)\n    \n    if not amount or not re.match(r\"^\\d+(\\.\\d+)?$\", amount) or float(amount) <= 0:\n        return\n    \n    amount = float(amount)\n    if amount > max_decrypt:\n        at(x + 2, y + 11, f\"amount too large (max: {max_decrypt:.6f})\", c['R'])\n        await awaitkey()\n        return\n    \n    at(x + 2, y + 11, f\"decrypt {amount:.6f} oct? [y/n]:\", c['B'] + c['y'])\n    if (await ainp(x + 30, y + 11)).strip().lower() != 'y':\n        return\n    \n    spin_task = asyncio.create_task(spin_animation(x + 2, y + 14, \"decrypting balance\"))\n    \n    ok, result = await decrypt_balance(amount)\n    \n    spin_task.cancel()\n    try:\n        await spin_task\n    except asyncio.CancelledError:\n        pass\n    \n    if ok:\n        at(x + 2, y + 14, \"✓ decryption submitted!\", c['bgg'] + c['w'])\n        at(x + 2, y + 15, f\"tx hash: {result.get('tx_hash', 'unknown')[:50]}...\", c['g'])\n        at(x + 2, y + 16, f\"will process in next epoch\", c['g'])\n    else:\n        at(x + 2, y + 14, f\"✗ error: {result.get('error', 'unknown')}\", c['bgr'] + c['w'])\n    \n    await awaitkey()\n\nasync def private_transfer_ui():\n    cr = sz()\n    cls()\n    fill()\n    w, hb = 80, 25\n    x = (cr[0] - w) // 2\n    y = (cr[1] - hb) // 2\n    \n    box(x, y, w, hb, \"private transfer\")\n    \n    enc_data = await get_encrypted_balance()\n    if not enc_data or enc_data['encrypted_raw'] == 0:\n        at(x + 2, y + 10, \"no encrypted balance available\", c['R'])\n        at(x + 2, y + 11, \"encrypt some balance first\", c['y'])\n        await awaitkey()\n        return\n    \n    at(x + 2, y + 2, f\"encrypted balance: {enc_data['encrypted']:.6f} oct\", c['g'])\n    at(x + 2, y + 3, \"─\" * (w - 4), c['w'])\n    \n    at(x + 2, y + 5, \"recipient address:\", c['y'])\n    to_addr = await ainp(x + 2, y + 6)\n    \n    if not to_addr or not b58.match(to_addr):\n        at(x + 2, y + 12, \"invalid address\", c['R'])\n        await awaitkey()\n        return\n    \n    if to_addr == addr:\n        at(x + 2, y + 12, \"cannot send to yourself\", c['R'])\n        await awaitkey()\n        return\n    \n    spin_task = asyncio.create_task(spin_animation(x + 2, y + 8, \"checking recipient\"))\n    \n    addr_info = await get_address_info(to_addr)\n    \n    spin_task.cancel()\n    try:\n        await spin_task\n    except asyncio.CancelledError:\n        pass\n    \n    if not addr_info:\n        at(x + 2, y + 12, \"recipient address not found on blockchain\", c['R'])\n        await awaitkey()\n        return\n    \n    if not addr_info.get('has_public_key'):\n        at(x + 2, y + 12, \"recipient has no public key\", c['R'])\n        at(x + 2, y + 13, \"they need to make a transaction first\", c['y'])\n        await awaitkey()\n        return\n    \n    at(x + 2, y + 8, f\"recipient balance: {addr_info.get('balance', 'unknown')}\", c['c'])\n    \n    at(x + 2, y + 10, \"amount:\", c['y'])\n    amount = await ainp(x + 10, y + 10)\n    \n    if not amount or not re.match(r\"^\\d+(\\.\\d+)?$\", amount) or float(amount) <= 0:\n        return\n    \n    amount = float(amount)\n    if amount > enc_data['encrypted'] :\n        at(x + 2, y + 14, f\"insufficient encrypted balance\", c['R'])\n        await awaitkey()\n        return\n    \n    at(x + 2, y + 12, \"─\" * (w - 4), c['w'])\n    at(x + 2, y + 13, f\"send {amount:.6f} oct privately to\", c['B'])\n    at(x + 2, y + 14, to_addr, c['y'])\n    at(x + 2, y + 16, \"[y]es / [n]o:\", c['B'] + c['y'])\n    \n    if (await ainp(x + 15, y + 16)).strip().lower() != 'y':\n        return\n    \n    spin_task = asyncio.create_task(spin_animation(x + 2, y + 18, \"creating private transfer\"))\n    \n    ok, result = await create_private_transfer(to_addr, amount)\n    \n    spin_task.cancel()\n    try:\n        await spin_task\n    except asyncio.CancelledError:\n        pass\n    \n    if ok:\n        at(x + 2, y + 18, \"✓ private transfer submitted!\", c['bgg'] + c['w'])\n        at(x + 2, y + 19, f\"tx hash: {result.get('tx_hash', 'unknown')[:50]}...\", c['g'])\n        at(x + 2, y + 20, f\"recipient can claim in next epoch\", c['g'])\n        at(x + 2, y + 21, f\"ephemeral key: {result.get('ephemeral_key', 'unknown')[:40]}...\", c['c'])\n    else:\n        at(x + 2, y + 18, f\"✗ error: {result.get('error', 'unknown')[:w-10]}\", c['bgr'] + c['w'])\n    \n    await awaitkey()\n\nasync def claim_transfers_ui():\n    cr = sz()\n    cls()\n    fill()\n    w, hb = 85, cr[1] - 4\n    x = (cr[0] - w) // 2\n    y = 2\n    \n    box(x, y, w, hb, \"claim private transfers\")\n    \n    spin_task = asyncio.create_task(spin_animation(x + 2, y + 2, \"loading pending transfers\"))\n    \n    transfers = await get_pending_transfers()\n    \n    spin_task.cancel()\n    try:\n        await spin_task\n    except asyncio.CancelledError:\n        pass\n    \n    if not transfers:\n        at(x + 2, y + 10, \"no pending transfers\", c['y'])\n        await awaitkey()\n        return\n    \n    at(x + 2, y + 2, f\"found {len(transfers)} claimable transfers:\", c['B'] + c['g'])\n    at(x + 2, y + 4, \"#   FROM                AMOUNT         EPOCH   ID\", c['c'])\n    at(x + 2, y + 5, \"─\" * (w - 4), c['w'])\n    \n    display_y = y + 6\n    max_display = min(len(transfers), hb - 12)\n    \n    for i, t in enumerate(transfers[:max_display]):\n        amount_str = \"[encrypted]\"\n        amount_color = c['y']\n        \n        if t.get('encrypted_data') and t.get('ephemeral_key'):\n            try:\n                shared = derive_shared_secret_for_claim(priv, t['ephemeral_key'])\n                amt = decrypt_private_amount(t['encrypted_data'], shared)\n                if amt:\n                    amount_str = f\"{amt/μ:.6f} OCT\"\n                    amount_color = c['g']\n            except:\n                pass\n        \n        at(x + 2, display_y + i, f\"[{i+1}]\", c['c'])\n        at(x + 8, display_y + i, t['sender'][:20] + \"...\", c['w'])\n        at(x + 32, display_y + i, amount_str, amount_color)\n        at(x + 48, display_y + i, f\"ep{t.get('epoch_id', '?')}\", c['c'])\n        at(x + 58, display_y + i, f\"#{t.get('id', '?')}\", c['y'])\n    \n    if len(transfers) > max_display:\n        at(x + 2, display_y + max_display + 1, f\"... and {len(transfers) - max_display} more\", c['y'])\n    \n    at(x + 2, y + hb - 6, \"─\" * (w - 4), c['w'])\n    at(x + 2, y + hb - 5, \"enter number to claim (0 to cancel):\", c['y'])\n    choice = await ainp(x + 40, y + hb - 5)\n    \n    if not choice or choice == '0':\n        return\n    \n    try:\n        idx = int(choice) - 1\n        if 0 <= idx < len(transfers):\n            transfer = transfers[idx]\n            transfer_id = transfer['id']\n            \n            spin_task = asyncio.create_task(spin_animation(x + 2, y + hb - 3, f\"claiming transfer #{transfer_id}\"))\n            \n            ok, result = await claim_private_transfer(transfer_id)\n            \n            spin_task.cancel()\n            try:\n                await spin_task\n            except asyncio.CancelledError:\n                pass\n            \n            if ok:\n                at(x + 2, y + hb - 3, f\"✓ claimed {result.get('amount', 'unknown')}!\", c['bgg'] + c['w'])\n                at(x + 2, y + hb - 2, \"your encrypted balance has been updated\", c['g'])\n            else:\n                error_msg = result.get('error', 'unknown error')\n                at(x + 2, y + hb - 3, f\"✗ error: {error_msg[:w-10]}\", c['bgr'] + c['w'])\n        else:\n            at(x + 2, y + hb - 3, \"invalid selection\", c['R'])\n    except ValueError:\n        at(x + 2, y + hb - 3, \"invalid number\", c['R'])\n    except Exception:\n        at(x + 2, y + hb - 3, f\"error occurred\", c['R'])\n    \n    await awaitkey()\n\nasync def exp():\n    cr = sz()\n    cls()\n    fill()\n    w, hb = 70, 15\n    x = (cr[0] - w) // 2\n    y = (cr[1] - hb) // 2\n    box(x, y, w, hb, \"export keys\")\n    \n    at(x + 2, y + 2, \"current wallet info:\", c['c'])\n    at(x + 2, y + 4, \"address:\", c['c'])\n    at(x + 11, y + 4, addr[:32] + \"...\", c['w'])\n    at(x + 2, y + 5, \"balance:\", c['c'])\n    n, b = await st()\n    at(x + 11, y + 5, f\"{b:.6f} oct\" if b is not None else \"---\", c['g'])\n    \n    at(x + 2, y + 7, \"export options:\", c['y'])\n    at(x + 2, y + 8, \"[1] show private key\", c['w'])\n    at(x + 2, y + 9, \"[2] save full wallet to file\", c['w'])\n    at(x + 2, y + 10, \"[3] copy address to clipboard\", c['w'])\n    at(x + 2, y + 11, \"[0] cancel\", c['w'])\n    at(x + 2, y + 13, \"choice: \", c['B'] + c['y'])\n    \n    choice = await ainp(x + 10, y + 13)\n    choice = choice.strip()\n    \n    if choice == '1':\n        at(x + 2, y + 7, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 8, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 9, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 10, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 11, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 13, \" \" * (w - 4), c['bg'])\n        \n        at(x + 2, y + 7, \"private key (keep secret!):\", c['R'])\n        at(x + 2, y + 8, priv[:32], c['R'])\n        at(x + 2, y + 9, priv[32:], c['R'])\n        at(x + 2, y + 11, \"public key:\", c['g'])\n        at(x + 2, y + 12, pub[:44] + \"...\", c['g'])\n        await awaitkey()\n        \n    elif choice == '2':\n        fn = f\"octra_wallet_{int(time.time())}.json\"\n        wallet_data = {\n            'priv': priv,\n            'addr': addr,\n            'rpc': rpc\n        }\n        os.umask(0o077)\n        with open(fn, 'w') as f:\n            json.dump(wallet_data, f, indent=2)\n        os.chmod(fn, 0o600)\n        at(x + 2, y + 7, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 8, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 9, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 10, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 11, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 13, \" \" * (w - 4), c['bg'])\n        at(x + 2, y + 9, f\"saved to {fn}\", c['g'])\n        at(x + 2, y + 11, \"file contains private key - keep safe!\", c['R'])\n        await awaitkey()\n        \n    elif choice == '3':\n        try:\n            import pyperclip\n            pyperclip.copy(addr)\n            at(x + 2, y + 7, \" \" * (w - 4), c['bg'])\n            at(x + 2, y + 9, \"address copied to clipboard!\", c['g'])\n        except:\n            at(x + 2, y + 7, \" \" * (w - 4), c['bg'])\n            at(x + 2, y + 9, \"clipboard not available\", c['R'])\n        at(x + 2, y + 11, \" \" * (w - 4), c['bg'])\n        await awaitkey()\n\ndef signal_handler(sig, frame):\n    stop_flag.set()\n    if session:\n        asyncio.create_task(session.close())\n    sys.exit(0)\n\nasync def main():\n    global session\n    \n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n    \n    if not ld():\n        sys.exit(\"[!] wallet.json error\")\n    if not addr:\n        sys.exit(\"[!] wallet.json not configured\")\n    \n    try:\n        await st()\n        await gh()\n        \n        while not stop_flag.is_set():\n            cmd = await scr()\n            \n            if cmd == '1':\n                await tx()\n            elif cmd == '2':\n                global lu, lh\n                lu = lh = 0\n                await st()\n                await gh()\n            elif cmd == '3':\n                await multi()\n            elif cmd == '4':\n                await encrypt_balance_ui()\n            elif cmd == '5':\n                await decrypt_balance_ui()\n            elif cmd == '6':\n                await private_transfer_ui()\n            elif cmd == '7':\n                await claim_transfers_ui()\n            elif cmd == '8':\n                await exp()\n            elif cmd == '9':\n                h.clear()\n                lh = 0\n            elif cmd in ['0', 'q', '']:\n                break\n    except Exception:\n        pass\n    finally:\n        if session:\n            await session.close()\n        executor.shutdown(wait=False)\n\nif __name__ == \"__main__\":\n    import warnings\n    warnings.filterwarnings(\"ignore\", category=ResourceWarning)\n    \n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        pass\n    except Exception:\n        pass\n    finally:\n        cls()\n        print(f\"{c['r']}\")\n        os._exit(0)\n","size_bytes":43492},"README.md":{"content":"# octra terminal client\n\na terminal wallet reminiscent of dos-era tui interfaces — but built with modern asynchronous architecture\n\n## what it does\n\n- shows your octra wallet balance and tx history  \n- lets you send one or many transactions  \n- exports your private key or full wallet file  \n\n## works on\n\n- linux  \n- mac  \n- windows (some features like clipboard may not work)\n\n## what you need\n\n- python 3.8 or higher  \n- internet connection  \n- your wallet file (private key)\n\n## how to install and run (step by step)\n\n1. open terminal  \n\n2. run these commands one by one:\n\n```bash\ngit clone https://github.com/octra-labs/octra_pre_client.git\ncd octra_pre_client\npython3 -m venv venv\nsource venv/bin/activate # for windows use: venv\\Scripts\\activate\npip install -r requirements.txt\ncp wallet.json.example wallet.json\n```\n\n3. open wallet.json and edit it (change placeholders to your wallet data):\n\n```json\n{\n  \"priv\": \"private-key-here\",\n  \"addr\": \"octxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",\n  \"rpc\": \"https://octra.network\"\n}\n```\n\n3. run\n\n```bash\n./run.sh       # on linux/mac\nrun.bat        # on windows\n```\n","size_bytes":1119}},"version":2}